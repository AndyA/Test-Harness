package TAP::Parser::Source::Perl;

use strict;
use vars qw($VERSION @ISA);

use constant IS_WIN32 => ( $^O =~ /^(MS)?Win32$/ );
use constant IS_MACOS => ( $^O eq 'MacOS' );
use constant IS_VMS   => ( $^O eq 'VMS' );

use TAP::Parser::Source;
@ISA = 'TAP::Parser::Source';

=head1 NAME

TAP::Parser::Source::Perl - Stream Perl output

=head1 VERSION

Version 2.99_03

=cut

$VERSION = '2.99_03';

=head1 DESCRIPTION

Takes a filename and hopefully returns a stream from it.  The filename should
be the name of a Perl program.

Note that this is a subclass of L<TAP::Parser::Source>.  See that module for
more methods.

=head1 SYNOPSIS

 use TAP::Parser::Source::Perl;
 my $perl   = TAP::Parser::Source::Perl->new;
 my $stream = $perl->source_file($filename)->get_stream;

=head1 METHODS

=head2 Class Methods

=head3 C<new>

 my $perl = TAP::Parser::Source::Perl->new;

Returns a new C<TAP::Parser::Source::Perl> object.

=head2 Instance Methods

=head3 C<source_file>

 my $perl = $source->source;
 $perl->source_file($filename);

Getter/setter for the source filename.  Will C<croak> if the C<$filename> does
not appear to be a file.

=cut

sub source_file {
    my $self = shift;
    return $self->{source_file} unless @_;
    my $filename = shift;
    unless ( -f $filename ) {
        $self->_croak("Cannot find ($filename)");
    }
    $self->{source_file} = $filename;
    return $self;
}

=head3 C<switches>

  my $switches = $perl->switches;
  my @switches = $perl->switches;
  $perl->switches( \@switches );

Getter/setter for the additional switches to pass to the perl executable.  One
common switch would be to set an include directory:

  $perl->switches( ['-Ilib'] );

=cut

sub switches {
    my $self = shift;
    unless (@_) {
        return wantarray ? @{ $self->{switches} } : $self->{switches};
    }
    my $switches = shift;
    $self->{switches} = [@$switches];    # force a copy
    return $self;
}

##############################################################################

=head3 C<get_stream>

 my $stream = $source->get_stream;

Returns a stream of the output generated by executing C<source_file>.

=cut

sub get_stream {
    my $self     = shift;
    
    # This is stuff that came in from a -I or use lib
    my @extra_libs = $self->_filtered_inc;

    my @switches   = $self->_switches;

    my($setup, $teardown) = (sub {}) x 2;
    if( grep { $_ eq "-T" } @switches ) {  # taint mode
        push @switches, $self->_libs2switches(
            @extra_libs,
            split /:/, $ENV{PERL5LIB} || $ENV{PERLLIB} || ''
        );
    }
    else {
        # We filter out any names containing colons because they will break
        # PERL5LIB
        @extra_libs = grep { $_ !~ /:/ } @extra_libs;
    
        my $have_perl5lib = exists $ENV{PERL5LIB};
        my $original_perl5lib = $ENV{PERL5LIB};

        $setup = sub {
            $ENV{PERL5LIB} = join ':',
                             grep { defined && length }
                                  @extra_libs, $ENV{PERL5LIB};
        };

        # Cargo culted from comments seen elsewhere about VMS / environment
        # variables. I don't know if this is actually necessary.
        $teardown = sub {
            if ($have_perl5lib) {
                $ENV{PERL5LIB} = $original_perl5lib;
            }
            else {
                delete $ENV{PERL5LIB};
            }
        };
    }

    my @command = $self->_get_command_for_switches(@switches)
      or $self->_croak("No command found!");


    return TAP::Parser::Iterator->new(
        {   command  => \@command,
            merge    => $self->merge,
            setup    => $setup,
            teardown => $teardown,
        }
    );
}

sub _get_command_for_switches {
    my $self     = shift;
    my @switches = @_;
    my $file     = $self->source_file;
    my $command  = $self->_get_perl;

    $file = qq["$file"] if ( $file =~ /\s/ ) && ( $file !~ /^".*"$/ );
    my @command = ( $command, @switches, $file );
    return @command;
}

sub _get_command {
    my $self = shift;
    return $self->_get_command_for_switches( $self->_switches );
}

sub _libs2switches {
    my $self = shift;
    return map {"-I$_"} @_;
}

sub _switches {
    my $self     = shift;
    my $file     = $self->source_file;
    my @switches = (
        $self->switches,
    );

    local *TEST;
    open( TEST, $file ) or print "can't open $file. $!\n";
    my $shebang = <TEST>;
    close(TEST) or print "can't close $file. $!\n";

    return unless defined $shebang;

    my $taint = ( $shebang =~ /^#!.*\bperl.*\s-\w*([Tt]+)/ );
    push @switches, "-$1" if $taint;

    # Quote the argument if there's any whitespace in it, or if
    # we're VMS, since VMS requires all parms quoted.  Also, don't quote
    # it if it's already quoted.
    for (@switches) {
        $_ = qq["$_"] if ( ( /\s/ || IS_VMS ) && !/^".*"$/ );
    }

    my %found_switch = map { $_ => 0 } @switches;

    # remove duplicate switches
    @switches
      = grep { defined $_ && $_ ne '' && !$found_switch{$_}++ } @switches;
    return @switches;
}


# Get the parts of @INC which are changed from the stock list AND
# preserve reordering of stock directories.
sub _filtered_inc {
    my $self = shift;
    my @inc  = @_;
    @inc = @INC unless @inc;

    if (IS_VMS) {

        # VMS has a 255-byte limit on the length of %ENV entries, so
        # toss the ones that involve perl_root, the install location
        @inc = grep !/perl_root/i, @inc;

    }
    elsif (IS_WIN32) {

        # Lose any trailing backslashes in the Win32 paths
        s/[\\\/+]$// foreach @inc;
    }

    my @default_inc = $self->_default_inc;

    my @new_inc;
    my %seen;
    for my $dir (@inc) {
        next if $seen{$dir}++;
                
        if( $dir eq ($default_inc[0] || '') ) {
            shift @default_inc;
        }
        else {
            push @new_inc, $dir;
        }
        
        shift @default_inc while @default_inc and $seen{$default_inc[0]};
    }

    return @new_inc;
}

{

    # cache this to avoid repeatedly shelling out to Perl.  This really speeds
    # up TAP::Parser.
    my @inc;

    sub _default_inc {
        return @inc if @inc;
        my $proto = shift;
        my $perl = $proto->_get_perl;
        chomp( @inc = `$perl -le "print join qq[\\n], \@INC"` );
        return @inc;
    }
}

sub _get_perl {
    my $proto = shift;
    return $ENV{HARNESS_PERL}           if defined $ENV{HARNESS_PERL};
    return Win32::GetShortPathName($^X) if IS_WIN32;
    return $^X;
}

1;
